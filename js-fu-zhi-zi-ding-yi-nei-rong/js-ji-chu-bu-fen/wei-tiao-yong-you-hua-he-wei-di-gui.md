# 尾调用优化和尾递归

今天来介绍一下**尾调用优化**和**尾递归**



首先我们认识一下啥叫尾调用

> **尾调用之所以与其他调用不同，就在于它的特殊的调用位置。**
>
> **我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数`A`的内部调用函数`B`，那么在`A`的调用帧上方，还会形成一个`B`的调用帧。等到`B`运行结束，将结果返回到`A`，`B`的调用帧才会消失。如果函数`B`内部还调用函数`C`，那就还有一个`C`的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。**
>
> **尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。**

没看懂的同学一定要多看两遍

```javascript
function tailCall() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
tailCall();

// 等同于
function tailCall() {
  return g(3);
}
tailCall();

// 等同于
tailCall(3);
```

上面代码中，如果函数`g`不是尾调用，函数`tailCall`就需要保存内部变量`m`和`n`的值、`g`的调用位置等信息。但由于调用`g`之后，函数`tailCall`就结束了，所以执行到最后一步，完全可以删除`tailCall(x)`的调用帧，只保留`g(3)`的调用帧。

说人话：函数`tailCall`里面

所以可以总结一下：“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。







